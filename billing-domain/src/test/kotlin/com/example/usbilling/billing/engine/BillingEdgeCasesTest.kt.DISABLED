package com.example.usbilling.billing.engine

import com.example.usbilling.billing.model.*
import com.example.usbilling.shared.*
import org.junit.jupiter.api.Test
import java.time.Instant
import java.time.LocalDate
import kotlin.test.assertEquals
import kotlin.test.assertTrue

class BillingEdgeCasesTest {
    
    @Test
    fun `meter rollover calculation handles correctly`() {
        // Meter reading rolls over from 99999 to 00050
        val startRead = MeterRead(
            meterId = "MTR-001",
            serviceType = ServiceType.ELECTRIC,
            readingValue = 99950.0,
            readDate = LocalDate.parse("2025-01-01T00:00:00Z"),
            usageUnit = UsageUnit.KWH
        )
        
        val endRead = MeterRead(
            meterId = "MTR-001",
            serviceType = ServiceType.ELECTRIC,
            readingValue = 50.0, // Rolled over
            readDate = LocalDate.parse("2025-01-31T23:59:59Z"),
            usageUnit = UsageUnit.KWH
        )
        
        val meterPair = MeterReadPair(
            meterId = "MTR-001",
            serviceType = ServiceType.ELECTRIC,
            startRead = startRead,
            endRead = endRead
        )
        
        val consumption = meterPair.calculateConsumption()
        
        // Should calculate: 100,000 - 99,950 + 50 = 100
        assertEquals(100.0, consumption, 0.01)
    }
    
    @Test
    fun `negative consumption is handled as meter rollover`() {
        val meterPair = MeterReadPair(
            meterId = "MTR-001",
            serviceType = ServiceType.ELECTRIC,
            startRead = MeterRead(
                meterId = "MTR-001",
                serviceType = ServiceType.ELECTRIC,
                readingValue = 1000.0,
                readDate = LocalDate.now(),
                usageUnit = UsageUnit.KWH
            ),
            endRead = MeterRead(
                meterId = "MTR-001",
                serviceType = ServiceType.ELECTRIC,
                readingValue = 100.0, // Lower than start
                readDate = LocalDate.now(),
                usageUnit = UsageUnit.KWH
            )
        )
        
        val consumption = meterPair.calculateConsumption()
        
        // Should be positive (rollover detected)
        assertTrue(consumption > 0.0)
        assertEquals(99100.0, consumption, 0.01) // 100,000 - 900
    }
    
    @Test
    fun `multiple meters per customer are calculated correctly`() {
        val tariff = RateTariff.FlatRate(
            customerCharge = Money(2000),
            ratePerUnit = Money(15),
            usageUnit = UsageUnit.KWH
        )
        
        // Customer has two electric meters
        val meterReads = listOf(
            MeterReadPair(
                meterId = "MTR-001",
                serviceType = ServiceType.ELECTRIC,
                startRead = createRead("MTR-001", 1000.0),
                endRead = createRead("MTR-001", 1500.0) // 500 kWh
            ),
            MeterReadPair(
                meterId = "MTR-002",
                serviceType = ServiceType.ELECTRIC,
                startRead = createRead("MTR-002", 2000.0),
                endRead = createRead("MTR-002", 2300.0) // 300 kWh
            )
        )
        
        val input = BillInput(
            billId = BillId("BILL-001"),
            billRunId = BillRunId("RUN-001"),
            utilityId = UtilityId("UTIL-001"),
            customerId = CustomerId("CUST-001"),
            billPeriod = createTestPeriod(),
            meterReads = meterReads,
            rateTariff = tariff,
            accountBalance = AccountBalance.zero()
        )
        
        val result = BillingEngine.calculateBill(input)
        
        // Should have 1 customer charge + 2 usage charges (one per meter)
        assertEquals(3, result.charges.size)
        
        val usageCharges = result.charges.filter { it.category == ChargeCategory.USAGE_CHARGE }
        assertEquals(2, usageCharges.size)
        
        // Total usage: 800 kWh * $0.15 = $120.00
        val totalUsageCharge = usageCharges.sumOf { it.amount.amount }
        assertEquals(12000L, totalUsageCharge)
    }
    
    @Test
    fun `partial billing period proration works correctly`() {
        val period = BillingPeriod(
            id = "2025-01",
            utilityId = UtilityId("UTIL-001"),
            startDate = LocalDate.of(2025, 1, 1),
            endDate = LocalDate.of(2025, 1, 31),
            billDate = LocalDate.of(2025, 2, 1),
            dueDate = LocalDate.of(2025, 2, 15),
            frequency = BillingFrequency.MONTHLY
        )
        
        // Service only from Jan 15 to Jan 31
        val prorationFactor = period.prorationFactor(
            LocalDate.of(2025, 1, 15),
            LocalDate.of(2025, 1, 31)
        )
        
        // 17 days out of 31 days
        assertEquals(17.0 / 31.0, prorationFactor, 0.01)
    }
    
    @Test
    fun `zero consumption produces customer charge only`() {
        val tariff = RateTariff.FlatRate(
            customerCharge = Money(1500),
            ratePerUnit = Money(10),
            usageUnit = UsageUnit.KWH
        )
        
        val input = BillInput(
            billId = BillId("BILL-001"),
            billRunId = BillRunId("RUN-001"),
            utilityId = UtilityId("UTIL-001"),
            customerId = CustomerId("CUST-001"),
            billPeriod = createTestPeriod(),
            meterReads = listOf(
                MeterReadPair(
                    meterId = "MTR-001",
                    serviceType = ServiceType.ELECTRIC,
                    startRead = createRead("MTR-001", 1000.0),
                    endRead = createRead("MTR-001", 1000.0) // No usage
                )
            ),
            rateTariff = tariff,
            accountBalance = AccountBalance.zero()
        )
        
        val result = BillingEngine.calculateBill(input)
        
        // Should have customer charge + zero usage charge
        val customerCharge = result.charges.find { it.code == "CUSTOMER_CHARGE" }
        assertTrue(customerCharge != null)
        assertEquals(Money(1500), customerCharge.amount)
        
        val usageCharge = result.charges.find { it.code == "ELECTRIC_USAGE" }
        assertTrue(usageCharge != null)
        assertEquals(Money(0), usageCharge.amount)
    }
    
    @Test
    fun `demand rate with demand charges calculates correctly`() {
        val tariff = RateTariff.DemandRate(
            customerCharge = Money(5000), // $50
            energyRatePerUnit = Money(8), // $0.08/kWh
            demandRatePerKw = Money(1200), // $12/kW
            usageUnit = UsageUnit.KWH
        )
        
        val demandReadings = listOf(
            DemandReading(
                meterId = "MTR-001",
                peakDemandKw = 150.0, // 150 kW peak
                readDate = LocalDate.parse("2025-01-15T14:30:00Z")
            )
        )
        
        val input = BillInput(
            billId = BillId("BILL-001"),
            billRunId = BillRunId("RUN-001"),
            utilityId = UtilityId("UTIL-001"),
            customerId = CustomerId("CUST-001"),
            billPeriod = createTestPeriod(),
            meterReads = listOf(
                MeterReadPair(
                    meterId = "MTR-001",
                    serviceType = ServiceType.ELECTRIC,
                    startRead = createRead("MTR-001", 10000.0),
                    endRead = createRead("MTR-001", 15000.0) // 5,000 kWh
                )
            ),
            rateTariff = tariff,
            accountBalance = AccountBalance.zero(),
            demandReadings = demandReadings
        )
        
        val result = BillingEngine.calculateBill(input)
        
        // Should have: customer charge + energy charge + demand charge
        val energyCharge = result.charges.find { it.code == "ELECTRIC_ENERGY" }
        assertTrue(energyCharge != null)
        assertEquals(Money(40000), energyCharge.amount) // 5,000 * $0.08
        
        val demandCharge = result.charges.find { it.code == "ELECTRIC_DEMAND" }
        assertTrue(demandCharge != null)
        assertEquals(Money(180000), demandCharge.amount) // 150 * $12
    }
    
    @Test
    fun `regulatory surcharge fixed amount is added`() {
        val surcharges = listOf(
            RegulatoryCharge(
                code = "PCA",
                description = "Power Cost Adjustment",
                calculationType = RegulatoryChargeType.FIXED,
                rate = Money(250) // $2.50 fixed
            )
        )
        
        val tariff = RateTariff.FlatRate(
            customerCharge = Money(1500),
            ratePerUnit = Money(10),
            usageUnit = UsageUnit.KWH,
            regulatorySurcharges = surcharges
        )
        
        val input = BillInput(
            billId = BillId("BILL-001"),
            billRunId = BillRunId("RUN-001"),
            utilityId = UtilityId("UTIL-001"),
            customerId = CustomerId("CUST-001"),
            billPeriod = createTestPeriod(),
            meterReads = listOf(
                MeterReadPair(
                    meterId = "MTR-001",
                    serviceType = ServiceType.ELECTRIC,
                    startRead = createRead("MTR-001", 1000.0),
                    endRead = createRead("MTR-001", 1500.0)
                )
            ),
            rateTariff = tariff,
            accountBalance = AccountBalance.zero()
        )
        
        val result = BillingEngine.calculateBill(input)
        
        val pcaCharge = result.charges.find { it.code == "PCA" }
        assertTrue(pcaCharge != null)
        assertEquals(Money(250), pcaCharge.amount)
        assertEquals(ChargeCategory.REGULATORY_CHARGE, pcaCharge.category)
    }
    
    private fun createRead(meterId: String, value: Double): MeterRead {
        return MeterRead(
            meterId = meterId,
            serviceType = ServiceType.ELECTRIC,
            readingValue = value,
            readDate = LocalDate.now(),
            usageUnit = UsageUnit.KWH
        )
    }
    
    private fun createTestPeriod(): BillingPeriod {
        return BillingPeriod(
            id = "2025-01",
            utilityId = UtilityId("UTIL-001"),
            startDate = LocalDate.of(2025, 1, 1),
            endDate = LocalDate.of(2025, 1, 31),
            billDate = LocalDate.of(2025, 2, 1),
            dueDate = LocalDate.of(2025, 2, 15),
            frequency = BillingFrequency.MONTHLY
        )
    }
}
